# goyo_dev/deploy/tekton/goyoai-backend-system/helm/templates/container-build-system-trigger.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: {{ required "A value for .Values.system_build_task_name is required!" .Values.system_build_task_name }}-trigger
  namespace: tekton-pipelines
spec:
  description: >-
    This Task triggers a Kaniko Job on Virtual Node and waits for completion.
  params:
    - name: container-registry-url
      type: string
    - name: container-registry-cache-url
      type: string
    - name: timestamp
      type: string
    - name: project-name
      type: string
      default: {{ .Values.project_name }}
    - name: git-short-sha
      type: string
    - name: module-name
      type: string
      description: "The module to build"
    - name: dockerfile-name
      type: string
    - name: giturl
      type: string
    - name: revision
      type: string
  
  workspaces:
    - name: {{ .Values.project_name }}
      description: Not used, but kept for compatibility
  
  results:
    - name: image-url
      description: The built image URL
  
  steps:
    - name: create-kaniko-job
      # image: {{ .Values.common_alpine_url }}
      image: alpine/kubectl:1.34.2
      script: |
        #!/bin/sh
        set -e
        # apk add --no-cache curl
        
        # echo "Detecting architecture..."
        # ARCH=$(uname -m)
        # if [ "$ARCH" = "aarch64" ]; then
        #   K8S_ARCH="arm64"
        # elif [ "$ARCH" = "x86_64" ]; then
        #   K8S_ARCH="amd64"
        # else
        #   echo "Unsupported architecture: $ARCH"
        #   exit 1
        # fi
        # echo "Architecture detected: $ARCH (using ${K8S_ARCH} for kubectl)"

        # curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/${K8S_ARCH}/kubectl"
        # chmod +x kubectl
        # mv kubectl /usr/local/bin/

        JOB_NAME="kaniko-build-$(params.module-name)-$(params.timestamp)"
        
        # ==========================================
        # BASE_IMAGE Í≤∞Ï†ï (ÌÜµÌï© Dockerfile ÏßÄÏõê)
        # ==========================================
        MODULE_NAME="$(params.module-name)"
        
        # system, scheduler, message Î™®ÎìàÏùÄ OpenTelemetry Ìè¨Ìï®
        if echo "${MODULE_NAME}" | grep -qE "(system|scheduler|message|portal|backoffice)"; then
          BASE_IMAGE="gdhb.goyoai.com/common/openjdk:17-jdk-oraclelinux8-otel-2.21.0"
          echo "‚úì Module '${MODULE_NAME}' will use OpenTelemetry base image"
        else
          BASE_IMAGE="gdhb.goyoai.com/common/openjdk:17-jdk-oraclelinux8"
          echo "‚úì Module '${MODULE_NAME}' will use standard base image"
        fi
        
        echo "Selected BASE_IMAGE: ${BASE_IMAGE}"
        echo ""

        cat <<EOF | kubectl apply --validate=false -f -
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: ${JOB_NAME}
          namespace: tekton-pipelines
          labels:
            tekton-trigger: "true"
            job-name: ${JOB_NAME}
            module: $(params.module-name)
        spec:
          ttlSecondsAfterFinished: 3600
          backoffLimit: 0
          template:
            metadata:
              labels:
                app: kaniko-build
                job-name: ${JOB_NAME}
                module: $(params.module-name)
            spec:
              nodeSelector:
                workload-type: tekton-build
              tolerations:
              - key: workload
                operator: Equal
                value: tekton-build
                effect: NoSchedule
              restartPolicy: Never
              serviceAccountName: tekton-ci-token
              containers:
              - name: kaniko-build
                image: gdhb.goyoai.com/common/kaniko-git:v1.23.2
                command:
                - /busybox/sh
                - -c
                - |
                  #!/bin/sh
                  set -e
                  
                  echo "=== Starting Build Process ==="
                  echo ""

                  # ==========================================
                  # Git Credentials
                  # ==========================================
                  echo "=== Git Credentials ==="
                  if [ -f /secrets/git-token/username ] && [ -f /secrets/git-token/password ]; then
                    GIT_USERNAME=\$(cat /secrets/git-token/username)
                    GIT_PASSWORD=\$(cat /secrets/git-token/password)
                    git config --global credential.helper store
                    mkdir -p /root
                    echo "https://\${GIT_USERNAME}:\${GIT_PASSWORD}@github.com" > /root/.git-credentials
                    chmod 600 /root/.git-credentials
                    echo "‚úì Git credentials configured"
                  fi
                  echo ""
                  
                  # ==========================================
                  # Git Clone
                  # ==========================================
                  echo "=== Git Clone ==="
                  git config --global user.name "Tekton CI"
                  git config --global user.email "ci@goyoai.com"
                  git config --global --add safe.directory /workspace
                  
                  if git clone -b $(params.revision) $(params.giturl) /workspace; then
                    cd /workspace
                    echo "‚úì Clone successful (commit: \$(git rev-parse --short HEAD))"
                  else
                    echo "‚úó Clone failed"
                    exit 1
                  fi
                  echo ""
                  
                  # ==========================================
                  # DEBUG: List workspace contents
                  # ==========================================
                  echo "=== DEBUG: Workspace Contents ==="
                  echo "Current directory: \$(pwd)"
                  echo ""
                  echo "Top-level files and directories:"
                  ls -la /workspace/
                  echo ""
                  echo "All files in workspace (first 50):"
                  find /workspace -type f 2>/dev/null | head -50
                  echo ""
                  echo "Looking for Dockerfile pattern: $(params.dockerfile-name)"
                  echo "Case-insensitive search for dockerfiles:"
                  find /workspace -iname "*dockerfile*" -type f 2>/dev/null || echo "No dockerfiles found"
                  echo ""
                  
                  # Check if dockerfile exists at expected path
                  DOCKERFILE_PATH="/workspace/$(params.dockerfile-name)"
                  echo "Checking expected path: \${DOCKERFILE_PATH}"
                  
                  if [ -f "\${DOCKERFILE_PATH}" ]; then
                    echo "‚úì Dockerfile found at: \${DOCKERFILE_PATH}"
                    ls -lh "\${DOCKERFILE_PATH}"
                  else
                    echo "‚úó Dockerfile NOT found at: \${DOCKERFILE_PATH}"
                    echo ""
                    echo "Searching for dockerfile in common locations..."
                    
                    # Try case variations
                    for name in \
                      "$(params.dockerfile-name)" \
                      "Dockerfile.unified" \
                      "Dockerfile-system-dev" \
                      "DOCKERFILE-SYSTEM-DEV" \
                      "Dockerfile" \
                      "dockerfile"; do
                      for base in \
                        "/workspace" \
                        "/workspace/$(params.module-name)" \
                        "/workspace/docker"; do
                        test_path="\${base}/\${name}"
                        if [ -f "\${test_path}" ]; then
                          echo "‚úì Found at: \${test_path}"
                          DOCKERFILE_PATH="\${test_path}"
                          ls -lh "\${DOCKERFILE_PATH}"
                          break 2
                        else
                          echo "‚úó Not found: \${test_path}"
                        fi
                      done
                    done
                    
                    # If still not found, try find
                    if [ ! -f "\${DOCKERFILE_PATH}" ]; then
                      echo ""
                      echo "Attempting wildcard search..."
                      FOUND_DOCKERFILE=\$(find /workspace -iname "*dockerfile*" -type f | head -1)
                      if [ -n "\${FOUND_DOCKERFILE}" ]; then
                        echo "‚úì Found dockerfile via search: \${FOUND_DOCKERFILE}"
                        DOCKERFILE_PATH="\${FOUND_DOCKERFILE}"
                        ls -lh "\${DOCKERFILE_PATH}"
                      fi
                    fi
                  fi
                  
                  # Final validation
                  echo ""
                  echo "=== Final Dockerfile Path Check ==="
                  if [ -f "\${DOCKERFILE_PATH}" ]; then
                    echo "‚úì Using Dockerfile: \${DOCKERFILE_PATH}"
                    echo "File size: \$(du -h \${DOCKERFILE_PATH} | cut -f1)"
                    echo "First 5 lines:"
                    head -5 "\${DOCKERFILE_PATH}"
                  else
                    echo "‚úó CRITICAL: No valid Dockerfile found!"
                    echo "Cannot proceed with build."
                    exit 1
                  fi
                  echo ""
                  
                  # ==========================================
                  # Pre-authenticate with Registry
                  # ==========================================
                  echo "=== Pre-authenticating with Registry ==="
                  
                  # Test authentication
                  echo "Testing Harbor connection..."
                  if command -v curl > /dev/null 2>&1; then
                    HTTP_CODE=\$(curl -s -o /dev/null -w "%{http_code}" -u "\${REGISTRY_USER}:\${REGISTRY_PASS}" https://\${REGISTRY_URL}/v2/)
                    if [ "\${HTTP_CODE}" = "200" ]; then
                      echo "‚úì Harbor authentication successful (HTTP \${HTTP_CODE})"
                    else
                      echo "‚ö† Harbor authentication returned HTTP \${HTTP_CODE}"
                      echo "Continuing anyway..."
                    fi
                  fi
                  echo ""
                  
                  # ==========================================
                  # Kaniko Build with Build Args (ÌÜµÌï© Dockerfile ÏßÄÏõê)
                  # ==========================================
                  echo "=== Kaniko Build ==="
                  IMAGE_TAG="$(params.container-registry-url)/$(params.module-name):$(params.git-short-sha)-$(params.timestamp)"
                  echo "Image: \${IMAGE_TAG}"
                  echo "Dockerfile: \${DOCKERFILE_PATH}"
                  echo "Context: /workspace"
                  echo "Module: $(params.module-name)"
                  echo "Base Image: ${BASE_IMAGE}"
                  echo ""
                  
                  # Calculate relative path for Dockerfile from context
                  RELATIVE_DOCKERFILE=\$(echo "\${DOCKERFILE_PATH}" | sed 's|^/workspace/||' | sed 's|^|./|')
                  echo "Relative Dockerfile path: \${RELATIVE_DOCKERFILE}"
                  echo ""
                  
                  # Verify once more before build
                  if [ ! -f "\${DOCKERFILE_PATH}" ]; then
                    echo "‚úó CRITICAL: Dockerfile does not exist at \${DOCKERFILE_PATH}"
                    exit 1
                  fi
                  
                  cd /workspace
                  echo "Changed to /workspace directory"
                  echo "PWD: \$(pwd)"
                  echo ""
                  
                  # ==========================================
                  # Dockerfile Î∞è Build Args Î∂ÑÍ∏∞ Ï≤òÎ¶¨
                  # ==========================================
                  echo "=== Module Configuration Selection ==="
                  echo "Module Name: $(params.module-name)"
                  echo ""

                  # ‚úÖ Virtual Node ÏµúÏ†ÅÌôî: Î™®Îì† Î™®Îìà ÎèôÏùº ÏÇ¨Ïñë
                  WORKERS_TO_USE=22
                  # MEMORY_TO_USE="50g"
                  # KOTLIN_DAEMON_MEMORY="25g"

                  case "$(params.module-name)" in
                    "goyoai-gointern-portal"|"goyoai-gointern-backoffice")
                      echo "‚úì Kapt module detected: $(params.module-name)"
                      DOCKERFILE_NAME_TO_USE="Dockerfile.kapt"

                      # ‚úÖ [ÏàòÏ†ï] Kapt Î™®ÎìàÏö© Î©îÎ™®Î¶¨ Ïû¨Î∂ÑÎ∞∞ (Pod 90G Í∏∞Ï§Ä)
                      # Gradle(8G) + Kotlin(80G) = 88G
                      GRADLE_MEM_TO_USE="10g"
                      KOTLIN_MEM_TO_USE="145g"
                      
                      # Kapt Î™®ÎìàÏö© Dockerfile Í≤ΩÎ°ú
                      KAPT_DOCKERFILE_PATH="/workspace/Dockerfile.kapt"
                      if [ -f "\${KAPT_DOCKERFILE_PATH}" ]; then
                        DOCKERFILE_PATH="\${KAPT_DOCKERFILE_PATH}"
                        RELATIVE_DOCKERFILE="./Dockerfile.kapt"
                        echo "‚úì Using Dockerfile.kapt: \${DOCKERFILE_PATH}"
                      else
                        echo "‚úó ERROR: Dockerfile.kapt not found at \${KAPT_DOCKERFILE_PATH}"
                        find /workspace -maxdepth 1 -name "Dockerfile*" -type f
                        exit 1
                      fi
                      ;;
                      
                    *)
                      echo "‚úì Standard module: $(params.module-name)"
                      DOCKERFILE_NAME_TO_USE="Dockerfile.unified"
                      
                      GRADLE_MEM_TO_USE="50g"
                      KOTLIN_MEM_TO_USE="25g"
                      # ÌëúÏ§Ä Î™®ÎìàÏö© Dockerfile Í≤ΩÎ°ú
                      UNIFIED_DOCKERFILE_PATH="/workspace/Dockerfile.unified"
                      if [ -f "\${UNIFIED_DOCKERFILE_PATH}" ]; then
                        DOCKERFILE_PATH="\${UNIFIED_DOCKERFILE_PATH}"
                        RELATIVE_DOCKERFILE="./Dockerfile.unified"
                        echo "‚úì Using Dockerfile.unified: \${DOCKERFILE_PATH}"
                      else
                        echo "‚úó ERROR: Dockerfile.unified not found at \${UNIFIED_DOCKERFILE_PATH}"
                        find /workspace -maxdepth 1 -name "Dockerfile*" -type f
                        exit 1
                      fi
                      ;;
                  esac

                  
                  echo ""
                  echo "=== Final Configuration ==="
                  echo "Dockerfile Path: \${DOCKERFILE_PATH}"
                  echo "Relative Path: \${RELATIVE_DOCKERFILE}"
                  echo "Gradle Workers: \${WORKERS_TO_USE}"
                  echo "Gradle Memory: \${MEMORY_TO_USE}"
                  echo ""
                  
                  # ÏµúÏ¢Ö Í≤ÄÏ¶ù
                  if [ ! -f "\${DOCKERFILE_PATH}" ]; then
                    echo "‚úó CRITICAL: Dockerfile NOT found at: \${DOCKERFILE_PATH}"
                    echo ""
                    echo "Available Dockerfiles in /workspace:"
                    find /workspace -maxdepth 1 -iname "*dockerfile*" -type f 2>/dev/null || echo "None found"
                    exit 1
                  fi
                  
                  echo "‚úì Dockerfile exists and ready to use"
                  echo "File size: \$(du -h \${DOCKERFILE_PATH} | cut -f1)"
                  echo ""
                  
                  # BUILD_ARGS ÏÑ§Ï†ï
                  if grep -q "ARG _G_MEM" "\${DOCKERFILE_PATH}"; then
                    echo "‚úì Kapt Dockerfile detected. Using _G_MEM and _K_MEM."
                    BUILD_ARGS="--build-arg=MODULE_NAME=$(params.module-name) --build-arg=BASE_IMAGE=${BASE_IMAGE} --build-arg=GRADLE_WORKERS=\${WORKERS_TO_USE} --build-arg=_G_MEM=\${GRADLE_MEM_TO_USE} --build-arg=_K_MEM=\${KOTLIN_MEM_TO_USE}"
                  elif grep -q "ARG GRADLE_MAX_MEMORY" "\${DOCKERFILE_PATH}"; then
                    echo "‚úì Standard Dockerfile detected. Using GRADLE_MAX_MEMORY."
                    BUILD_ARGS="--build-arg=MODULE_NAME=$(params.module-name) --build-arg=BASE_IMAGE=${BASE_IMAGE} --build-arg=GRADLE_WORKERS=\${WORKERS_TO_USE} --build-arg=GRADLE_MAX_MEMORY=\${GRADLE_MEM_TO_USE}"
                  else
                    echo "‚úì Legacy Dockerfile detected (no memory args)."
                    BUILD_ARGS="--build-arg=MODULE_NAME=$(params.module-name) --build-arg=BASE_IMAGE=${BASE_IMAGE} --build-arg=GRADLE_WORKERS=\${WORKERS_TO_USE}"
                  fi
                  
                  echo "Build Args: \${BUILD_ARGS}"
                  echo ""    

                  /kaniko/executor \
                    --context=/workspace \
                    --dockerfile=\${RELATIVE_DOCKERFILE} \
                    --destination=\${IMAGE_TAG} \
                    \${BUILD_ARGS} \
                    --force \
                    --skip-tls-verify \
                    --skip-push-permission-check \
                    --skip-unused-stages \
                    --use-new-run \
                    --ignore-path=/var/spool/mail \
                    --ignore-path=/var/mail \
                    --ignore-path=/var/spool \
                    --cache=false \
                    --cache-copy-layers=false \
                    --snapshot-mode=time \
                    --ignore-var-run \
                    --cleanup \
                    --cache-dir=/cache \
                    --verbosity=info
                  
                  BUILD_EXIT=\$?
                  
                  if [ \${BUILD_EXIT} -ne 0 ]; then
                    echo ""
                    echo "‚úó Build failed with exit code \${BUILD_EXIT}"
                    exit 1
                  fi
                  
                  echo ""
                  echo "‚úì Build complete!"

                env:
                - name: GRADLE_USER_HOME
                  value: "/root/.gradle"
                - name: GRADLE_OPTS
                  value: "-Dorg.gradle.daemon=false"

                - name: DOCKER_CONFIG
                  value: "/kaniko/.docker"
                volumeMounts:
                - name: workspace
                  mountPath: /workspace
                - name: kaniko-cache
                  mountPath: /cache
                - name: git-credentials
                  mountPath: /secrets/git-token
                  readOnly: true
                - name: harbor-config
                  mountPath: /kaniko/.docker
                  readOnly: true
                
                resources:
                  requests:
                    memory: "50Gi"
                    cpu: "8000m"
                  limits:
                    memory: "50Gi"
                    cpu: "8000m"
                    
              volumes:
              - name: workspace
                emptyDir: {}
              - name: kaniko-cache
                emptyDir: {}
              - name: git-credentials
                secret:
                  secretName: git-token
              - name: harbor-config
                secret:
                  secretName: kaniko-secret
                  items:
                  - key: config.json
                    path: config.json
                    mode: 0644                              
        EOF
        
        echo "Job ${JOB_NAME} created successfully"
        echo "${JOB_NAME}" > /tmp/job-name
      volumeMounts:
        - name: job-info
          mountPath: /tmp
    
    - name: wait-for-job
      # image: {{ .Values.common_alpine_url }}
      image: alpine/kubectl:1.34.2
      script: |
        #!/bin/sh
        set -e
        # apk add --no-cache curl

        # echo "Detecting architecture..."
        # ARCH=$(uname -m)
        # if [ "$ARCH" = "aarch64" ]; then
        #   K8S_ARCH="arm64"
        # elif [ "$ARCH" = "x86_64" ]; then
        #   K8S_ARCH="amd64"
        # else
        #   echo "Unsupported architecture: $ARCH"
        #   exit 1
        # fi
        
        # curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/${K8S_ARCH}/kubectl"
        # chmod +x kubectl
        # mv kubectl /usr/local/bin/
        
        JOB_NAME=$(cat /tmp/job-name)
        
        echo "=========================================="
        echo "üì¶ Waiting for Kaniko Build Job"
        echo "=========================================="
        echo "Job Name: ${JOB_NAME}"
        echo "Timeout: 1800 seconds (30 minutes)"
        echo "=========================================="
        echo ""
        
        # PodÍ∞Ä ÏÉùÏÑ±Îê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞ (ÏµúÎåÄ 60Ï¥à)
        echo "‚è≥ Waiting for Pod to be created..."
        POD_NAME=""
        for i in $(seq 1 60); do
          POD_NAME=$(kubectl get pods -n tekton-pipelines -l job-name=${JOB_NAME} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$POD_NAME" ]; then
            echo "‚úì Pod created: ${POD_NAME}"
            break
          fi
          sleep 1
        done
        
        if [ -z "$POD_NAME" ]; then
          echo "‚úó Pod creation timeout"
          exit 1
        fi
        
        # PodÍ∞Ä Running ÏÉÅÌÉúÍ∞Ä Îê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞ (ÏµúÎåÄ 120Ï¥à)
        echo ""
        echo "‚è≥ Waiting for Pod to start running..."
        for i in $(seq 1 120); do
          POD_STATUS=$(kubectl get pod ${POD_NAME} -n tekton-pipelines -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
          if [ "$POD_STATUS" = "Running" ] || [ "$POD_STATUS" = "Succeeded" ]; then
            echo "‚úì Pod is ${POD_STATUS}"
            break
          fi
          
          # Pod ÏÉÅÌÉú Ï∂úÎ†•
          if [ $((i % 10)) -eq 0 ]; then
            echo "  Pod status: ${POD_STATUS} (${i}s)"
          fi
          sleep 1
        done
        
        echo ""
        echo "=========================================="
        echo "üìã Streaming Kaniko Build Logs"
        echo "=========================================="
        echo ""
        
        # Î°úÍ∑∏ Ïä§Ìä∏Î¶¨Î∞çÏùÑ Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Ïã§Ìñâ
        kubectl logs -f ${POD_NAME} -n tekton-pipelines -c kaniko-build 2>/dev/null &
        LOG_PID=$!
        
        # Job ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ
        TIMEOUT=1800
        ELAPSED=0
        INTERVAL=5
        
        while [ $ELAPSED -lt $TIMEOUT ]; do
          # Job ÏÉÅÌÉú ÌôïÏù∏
          STATUS=$(kubectl get job ${JOB_NAME} -n tekton-pipelines -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}' 2>/dev/null || echo "")
          FAILED=$(kubectl get job ${JOB_NAME} -n tekton-pipelines -o jsonpath='{.status.conditions[?(@.type=="Failed")].status}' 2>/dev/null || echo "")
          
          if [ "$STATUS" = "True" ]; then
            # Î°úÍ∑∏ ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä ÎÅùÎÇ† ÎïåÍπåÏßÄ Ïû†Ïãú ÎåÄÍ∏∞
            sleep 2
            kill $LOG_PID 2>/dev/null || true
            
            echo ""
            echo "=========================================="
            echo "‚úÖ Build Completed Successfully!"
            echo "=========================================="
            echo "Image: $(params.container-registry-url)/$(params.module-name):$(params.git-short-sha)-$(params.timestamp)"
            echo "=========================================="
            
            echo "$(params.container-registry-url)/$(params.module-name):$(params.git-short-sha)-$(params.timestamp)" > $(results.image-url.path)
            exit 0
          fi
          
          if [ "$FAILED" = "True" ]; then
            kill $LOG_PID 2>/dev/null || true
            
            echo ""
            echo "=========================================="
            echo "‚ùå Build Failed"
            echo "=========================================="
            echo ""
            echo "=== Last 200 lines of logs ==="
            kubectl logs ${POD_NAME} -n tekton-pipelines -c kaniko-build --tail=200 2>/dev/null || true
            echo ""
            echo "=== Pod Status ==="
            kubectl describe pod ${POD_NAME} -n tekton-pipelines | tail -50
            exit 1
          fi
          
          sleep $INTERVAL
          ELAPSED=$((ELAPSED + INTERVAL))
        done
        
        # Timeout
        kill $LOG_PID 2>/dev/null || true
        
        echo ""
        echo "=========================================="
        echo "‚è±Ô∏è  Build Timeout (30 minutes)"
        echo "=========================================="
        echo ""
        echo "=== Last 200 lines of logs ==="
        kubectl logs ${POD_NAME} -n tekton-pipelines -c kaniko-build --tail=200 2>/dev/null || true
        exit 1
      volumeMounts:
        - name: job-info
          mountPath: /tmp
  
  volumes:
    - name: job-info
      emptyDir: {}